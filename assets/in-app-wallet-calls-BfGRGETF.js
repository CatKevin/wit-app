import{k as m,r as h,bM as p,aq as w,a4 as f,bN as T}from"./index-D5pZEnR3.js";import{s as b}from"./send-transaction-ciAOm1aA.js";import{r as g}from"./random-CQNoyHG_.js";async function H(o){const{account:t,transactions:c}=o;if(!t)throw new Error("not connected");if(c.length===0)throw new Error("No transactions to send");const n=c[0];if(!n)throw new Error("No transactions to send");if(t.sendBatchTransaction){const a=await Promise.all(c.map(async s=>{const[r,l,e,d]=await Promise.all([m(s),h(s.to),h(s.accessList),h(s.value)]);return{accessList:e,chainId:s.chain.id,data:r,to:l,value:d}}));return{...await t.sendBatchTransaction(a),chain:n.chain,client:n.client}}throw new Error("Account doesn't implement sendBatchTransaction")}async function k(o){const t=await b(o);return p(t)}const u=new w(1e3);async function N(o){const{account:t,calls:c}=o,n=c.map(s=>({...s,chain:o.chain})),a=[],i=g(65);if(u.set(i,a),t.sendBatchTransaction){const s=await H({account:t,transactions:n});a.push(s.transactionHash),u.set(i,a)}else for(const s of n){const r=await k({account:t,transaction:s});a.push(r.transactionHash),u.set(i,a)}return i}async function v(o){const{chain:t,client:c,id:n}=o,a=u.get(n);if(!a)throw new Error("Failed to get calls status, unknown bundle id");const i=f({chain:t,client:c});let s="success";const r=await Promise.all(a.map(l=>T(i,{hash:l}).then(e=>({blockHash:e.blockHash,blockNumber:e.blockNumber,gasUsed:e.gasUsed,logs:e.logs.map(d=>({address:d.address,data:d.data,topics:d.topics})),status:e.status,transactionHash:e.transactionHash})).catch(()=>(s="pending",null))));return{atomic:!1,chainId:t.id,id:n,receipts:r.filter(l=>l!==null),status:s,statusCode:200,version:"2.0.0"}}export{v as inAppWalletGetCallsStatus,N as inAppWalletSendCalls};
